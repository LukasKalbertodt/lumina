/**
\page s_vertexseq Create a VertexSeq

Vertices are the data that is processed by the OpenGL pipeline. So we need
vertices to draw anything. VertexSeq helps us with that by providing a easy
way to manage a set of vertices with a given order. The order is important,
because it determines how OpenGL interprets the data. You have two 
possibilities to give vertices an order:
- Do nothing: If you just specify vertices, the order is the same as the order
in which those vertices lay in the memory
- Use an index buffer: The index buffer is a clever tool to save memory, 
because you don't have to specify any vertex twice. For more information about
index buffers see somewhere else.

Note: This tutorial won't cover how to draw a VertexSeq, but just to fill it.

First we want to create a simple triangle. A triangle has 3 vertices. Our 
vertices just need a position on the screen (x,y -> 2 floats). Our code looks
like that:
\code
VertexSeq triangle;
triangle.create(2, 3);
\endcode

Now we have created all necessary buffers for our triangle. We just need to 
fill in the data. In order to do so we have to prime our VertexSeq. We need to
pass some template arguments to prime, because it want to know how our vertex
looks like. We said that we just need a screen position, so our vertex consists
just of a Vec2f. We also pass a lambda to prime.

In the lambda we do the main work. We write some data (the screen position)
to the buffer.
\code
triangle.prime<Vec2f>([](HotVertexSeq& hotTri) {
  hotTri.vertex[0] = Vec2f(0.5f, 0.f);
  hotTri.vertex[1] = Vec2f(0.f, 1.f);
  hotTri.vertex[2] = Vec2f(1.f, 1.f);
});
\endcode

The sequence is ready for drawing now. 

What if we wanted to create a quad instead of a triangle? We need 4 vertices
for the quad. But to draw them we need an index buffer specify an order. 
Let's suppose we want to draw with the primitive type Triangle (and not 
TriangleStrip). We then need 6 indicies to define 2 triangles. The size of one
vertex hasn't changed. Our new code:
\code
VertexSeq quad;
quad.create(2, 4, 6);

quad.prime<Vec2f>([](HotVertexSeq& hotQuad) {
  hotQuad.vertex[0] = Vec2f(0.f, 0.f);
  hotQuad.vertex[1] = Vec2f(1.f, 0.f);
  hotQuad.vertex[2] = Vec2f(1.f, 1.f);
  hotQuad.vertex[3] = Vec2f(0.f, 1.f);

  hotQuad.index[0] = 0;
  hotQuad.index[1] = 2;
  hotQuad.index[2] = 1;
  hotQuad.index[3] = 0;
  hotQuad.index[4] = 1;
  hotQuad.index[5] = 3;
});
\endcode

Note: You should pay attention to the winding order. 


\see \ref lumina::VertexSeq "VertexSeq"
\see \ref lumina::HotVertexSeq "HotVertexSeq"

*/